Learning to leap over the pitfall of premature implemetation details.

duplicates vs reoccurrences
Not about the elements themselves, but their occurrences
what made me realize this is oac/2016/1/2
if wanted to implement as duplicates, could not be lazy...
unless I would break what I would expect from the function.
Made me realize duplicates was improper abstraction! Too specific! Premature implementation detail!
Why does it matter though?






overcoming the imperative-declarative ambuiguity of English
= always imperative, start name with -> to 'cheat out' a declarative name





The rationale of Uncle Bob's "three lines per function" rule and the two uses of a name.
uses of a name:
- to summarize meaning
- to provide a context for an implementation

I came to realize the second use of a name by this example
<< see cfn/assets, bottom few functions >>

Uncle Bob's "three lines per function" rule supports understandability through brevity.
Minimal irrelevant details = maximal abstraction.
The abstraction is achieved by names.
However,
- These names need not be functions, but can be values also;
- These names need not be introduced outside function scope; let block can be fine.






Why programming is useful and why I love it so much; or: software is an implementation detail.

externalization

Bonus: I love Clojure so much because to me expressing myself in it feels most natural of all programming languages.





What's the benefit of simplicity?

problem -> perceived problem -> solution -> implementation -> test

An implementation is simple when it straightforwardly maps to the problem.

Keeping things simple will allow us realize if what we're doing is actually what we're supposed to be doing.

Being simple is about minimalism; unburden mind as much as possible to we can think of relevant things.




Optimizing code for storytelling and why I don't like space-dictated syntax such as Python's.

use spacing to make reader aware of things.

Juggle the (non) use of threading macro's to increase storytelling.






Why for most people 'real world' programming languages are bad tools to learn programming.
designed for productivity (are conventient) and performance (provide many options that are similar but different).
Thus they have much implicit and irregular behavior and have irregular syntax.







Analyzing clojure core functions with a clojure program.






A dream of declarative data transformations.
Meander
looked in syntax, quickly boggled...
Makes sense: higher level stuff, can express more... if you want all that expressivity 'first class', language needs to be bigger.
Same as chinese vs english.
Chinese has many characters, each representing a thing. English few characters, but can easily compose with knowing little.

Get the same feeling with meander; to makes clear there is a limit in how abstract/expressive a _general programming language_ can or should be.
Although the problem statement of Meander hit home immediately, for now I am content with keeping my toolkit mentally managable at the cost of expressivity.






Why I don't like the word 'coding' and why I don't like the 'coding' interviews I see on YouTube;
and: the difference and relations between computer science, coding, programming and software engineering
Comment on 'Google coding interview'.
"makes me want to give up coding".
He was asking CS questions, not coding questions!
Programming is the combination of computer science AND coding.
Need both: educate yourself!
coding is an implementation detail (see some other blog post)
Software engineering is programming and much more. About ethics, best practises and disciplines.






why a theoretical computer science education is very worthwhile for a software engineering job.

At work, people from university not taken seriously because they can't do anything.
In general: true.
At uni don't learn much practical stuff. Never touched a version control system. Never touched a terminal.
Spent years developing insights on stuff like time complexity, something which during my engineering job only rarely is relevant knowledge.
However, had the opportunity to spend years developing insights;
Engineering is what work is; you get the opportunity to learn on the job.
On an engineering job, don't get the oppornity; if you do, it's not often.
I learned a lot about engineering (functional programming, stratified design, clean code, clean architecture, the tools, the practises).

example: state machines; non-uni guy started building, spent days debugging something.
I took a look, after 30 minutes spotted a potential deadlock.
During meeting could rebuff a complaint about adding an empty thing to db for each other thing; that would be O(N+1) per thing instead of O(N); no biggie.






'Old school' vs. 'new school' functional programming; and: functional programming is a bad name.





Writing detailed explanations of my opinions; a programming exercise.

started with merge requests.
Made me wonder: stuff that's 'ugly'; are there 'universal rules' for beauty?
such as: narrow scope of data asap.
equal names equal semantics.






seperating plan from action
e.g. what needs to be drawn to drawing it.
Tellman's Always Be Composing; data more composable/maleable.
Normand: clearly distinguishing data, calculating, action
writing a program is exactly that!
seperating the plan from action allows compiler to do smart things, allows humans to reason about the plan without any action having to take place.
